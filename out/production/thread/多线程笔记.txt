多线程笔记

1. 对一个实例执行start()方法后,CPU以不确定的方式,或者说是以随机的时间来调用线程中的run方法,主线程优先权为5
2. 每个Java应用程序都有一个执行Main()函数的默认主线程.这个就是主线程.应用程序也可以创建线程在后台运行.Java主要是通过Java.Lang.Thread类以及Java.lang.Runnable接口来实现线程机制的.这边所有的都是其余线程
3. Linux系统,线程优先级默认5.
4. 综上所述,主线程和其他线程是两个部分,互相执行,互不干扰.谁先谁后,随机.
5. 每个线程都有一个属于自己的实例变量(单独的内存,实例域),那么互不影响.
6. 活动状态就是线程已经启动且尚未终止。线程处于正在运行或准备运行的状态.
7. interrupt(): 将当前线程的中断状态置为true. isInterrupted(): 检查当前线程中断状态
8. join(): 在很多情况下，主线程生成并起动了子线程，如果子线程里要进行大量的耗时的运算，主线程往往将于子线程之前结束，但是如果主线程处理完其他的事务后，需要用到子线程的处理结果，也就是主线程需要等待子线程执行完成之后再结束，这个时候就要用到join()方法了.
9. yield(): 方法的作用是放弃当前的CPU资源，将它让给其他的任务去占用CPU时间。注意：放弃的时间不确定，可能一会就会重新获得CPU时间片.
10. 线程优先级具有随机性也就是说线程优先级高的不一定每一次都先执行完.
11. 守护线程：运行在后台，为其他前台线程服务.也可以说守护线程是JVM中非守护线程的 “佣人”
12. setDaemon(boolean on): 将此线程标记为 daemon线程或用户线程
13. 线程属于一次性消耗品，在执行完run()方法之后线程便会正常结束了，线程结束后便会销毁，不能再次start,只能重新建立新的线程对象，但有时run()方法是永远不会结束的。例如在程序中使用线程进行Socket监听请求，或是其他的需要循环处理的任务。在这种情况下，一般是将这些任务放在一个循环中，如while循环.
14. 在线程未进入阻塞的代码段时是可以通过isInterrupted()来判断中断是否发生来控制循环，在进入阻塞状态后要通过捕获异常来退出循环。因此使用interrupt()来退出线程的最好的方式应该是两种情况都要考虑
public void run()
{        
	while (!isInterrupted()){ //非阻塞过程中通过判断中断标志来退出
            try{
                Thread.sleep(5*1000);//阻塞过程捕获中断异常来退出
            } catch(InterruptedException e){
                e.printStackTrace();
                break;//捕获到异常之后，执行break跳出循环。
            }
        }
}

15. thread.join()方法会让当前线程等待,优先执行thread线程
16. 主线程会等待其他线程运行结束
17. await()方法会把当前线程放到阻塞队列里面去,并释放锁,当再次得到锁时,会从被阻塞的位置继续执行
18. signalAll()激活条件队列的所有线程,让他们离开条件队列,成为可运行状态
19. ReentrantLock拥有重入锁的特性,并且拥有一个记录锁个数的属性
20. synchronized相当于以当前类为锁类,原理为:Java对象都有一个内部锁,利用该内部锁锁住同步块;在synchronized里,wait()相当于this.await();notifyAll()相当于this.signalAll()方法
21. 如果同步块是静态方法或修饰类.class,那么整个类被锁上;如果同步块是普通方法或修饰类的对象,那么仅在当前对象上加锁;同一个类的不同对象的对象锁互不干扰;对于同一个类的不同对象的类锁是同一个;对象锁和类锁是独立的，互不干扰
22. tryLock()方法会尝试申请锁,如果失败,返回false
if (lock.tryLock()) {
    try {
        执行代码...
    }
    finally {
        lock.unlock();
    }
}
else {
    获取锁失败之后的代码
}

23. Java没有处理死锁的机制,但是带超时参数的tryLock()可以打破死锁
24. 读写锁适用于:读锁,允许多个读操作同时进行,排斥所有的写操作;写锁,允许一个写操作,排斥所有其他的写操作和所有的读操作
25. 阻塞队列是一个同步了队列基本操作的队列,另外,还提供了4个重要的方法:put(),插入元素,若队列满,则等待;take(),取出首元素,若队列空,则等待;offer(超时参数),如果队列满,等待一定时间,若还没插入成功,返回false;poll(超时参数),若队列空,等待一定时间,若取出失败,返回false
26. 阻塞队列适用于多个生产者(进行put()操作)或多个消费者(进行take()操作)针对同一个队列进行操作且可以保证安全的队列,其中,多个生产者操作或多个消费者操作是由多线程执行任务时产生的
27. Callable相当于带返回值的Runnable接口, Future接口用于保存计算结果,FutureTask是一个实现类,实现了Runnable和Future接口,一般把它和Callable实现类以及返回值搭配使用
28. Callable由ExecutorService的submit()方法启动并返回Future<?>,或者用FutureTask封装好Callable,然后用Thread启动:FutureTask task = new FutureTask<?>(new MyCallable);
29. 线程池可以由Executors的静态方法生成
30. fork-join框架可以动用空闲线程完成计算(递归时递归线程不止一个在运算),适用于分而治之的情景;RecursiveAction:用于无结果返回的子任务;RecursiveTask:用于有结果返回的子任务